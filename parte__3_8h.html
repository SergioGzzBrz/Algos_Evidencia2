<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Project Template: /home/runner/work/Algos_Evidencia2/Algos_Evidencia2/src/parte_3.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Project Template
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parte_3.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;limits&gt;</code><br />
<code>#include &lt;queue&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for parte_3.h:</div>
<div class="dyncontent">
<div class="center"><img src="parte__3_8h__incl.png" border="0" usemap="#a_2home_2runner_2work_2Algos__Evidencia2_2Algos__Evidencia2_2src_2parte__3_8h" alt=""/></div>
</div>
</div>
<p><a href="parte__3_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8da5e9eb7c29d66261494eadf34b668b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parte__3_8h.html#a8da5e9eb7c29d66261494eadf34b668b">bfs_find_path</a> (const vector&lt; vector&lt; int &gt;&gt; &amp;adjacency_matrix, vector&lt; int &gt; &amp;parent, int n, int s, int d)</td></tr>
<tr class="memdesc:a8da5e9eb7c29d66261494eadf34b668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realiza una búsqueda en amplitud (BFS) para encontrar un camino desde el nodo fuente 's' hasta el nodo destino 'd'. Si encuentra un camino, actualiza el arreglo 'parent' para almacenar el nodo anterior de cada nodo en el camino.  <a href="parte__3_8h.html#a8da5e9eb7c29d66261494eadf34b668b">More...</a><br /></td></tr>
<tr class="separator:a8da5e9eb7c29d66261494eadf34b668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5901f525f28f21a149a22cadc239b41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parte__3_8h.html#ae5901f525f28f21a149a22cadc239b41">ford_fulkerson</a> (const vector&lt; vector&lt; int &gt;&gt; &amp;flow_adjacency_matrix, int n, int s, int t)</td></tr>
<tr class="memdesc:ae5901f525f28f21a149a22cadc239b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algoritmo de Ford-Fulkerson para calcular el flujo máximo en una red de flujo. Usa BFS para encontrar caminos aumentantes y actualiza las capacidades residuales.  <a href="parte__3_8h.html#ae5901f525f28f21a149a22cadc239b41">More...</a><br /></td></tr>
<tr class="separator:ae5901f525f28f21a149a22cadc239b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc70ae4a9a910e2ccf5661646cf2bd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parte__3_8h.html#a8cc70ae4a9a910e2ccf5661646cf2bd6">maximum_flow</a> (const vector&lt; vector&lt; int &gt;&gt; &amp;flow_adjacency_matrix, int n)</td></tr>
<tr class="memdesc:a8cc70ae4a9a910e2ccf5661646cf2bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcula e imprime el flujo máximo en una red de flujo.  <a href="parte__3_8h.html#a8cc70ae4a9a910e2ccf5661646cf2bd6">More...</a><br /></td></tr>
<tr class="separator:a8cc70ae4a9a910e2ccf5661646cf2bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8da5e9eb7c29d66261494eadf34b668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da5e9eb7c29d66261494eadf34b668b">&#9670;&nbsp;</a></span>bfs_find_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bfs_find_path </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacency_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Realiza una búsqueda en amplitud (BFS) para encontrar un camino desde el nodo fuente 's' hasta el nodo destino 'd'. Si encuentra un camino, actualiza el arreglo 'parent' para almacenar el nodo anterior de cada nodo en el camino. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">adjacency_matrix</td><td>Matriz de adyacencia que representa las capacidades de las aristas entre nodos. </td></tr>
    <tr><td class="paramname">parent</td><td>Arreglo que almacena el nodo anterior de cada nodo en el camino encontrado. </td></tr>
    <tr><td class="paramname">n</td><td>Número de nodos en el grafo. </td></tr>
    <tr><td class="paramname">s</td><td>Nodo fuente de la búsqueda. </td></tr>
    <tr><td class="paramname">d</td><td>Nodo destino de la búsqueda. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> si se encontró un camino desde 's' a 'd', de lo contrario <code>false</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Complejidad: O(n + e), donde 'n' es el número de nodos y 'e' son las aristas </dd></dl>

</div>
</div>
<a id="ae5901f525f28f21a149a22cadc239b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5901f525f28f21a149a22cadc239b41">&#9670;&nbsp;</a></span>ford_fulkerson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ford_fulkerson </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>flow_adjacency_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Algoritmo de Ford-Fulkerson para calcular el flujo máximo en una red de flujo. Usa BFS para encontrar caminos aumentantes y actualiza las capacidades residuales. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flow_adjacency_matrix</td><td>Matriz de adyacencia que representa las capacidades de las aristas. </td></tr>
    <tr><td class="paramname">n</td><td>Número de nodos en el grafo. </td></tr>
    <tr><td class="paramname">s</td><td>Nodo fuente. </td></tr>
    <tr><td class="paramname">t</td><td>Nodo sumidero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>El flujo máximo de la red. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Complejidad: O(max_flow * e), donde 'max_flow' es el flujo máximo y 'e' es el número de aristas </dd></dl>
<p>Grafo residual, inicializado con las capacidades originales de las aristas</p>
<p>Arreglo para almacenar los padres de los nodos</p>
<p>Inicializamos el flujo máximo a 0</p>
<p>Inicializamos el flujo de la ruta como el valor máximo</p>

</div>
</div>
<a id="a8cc70ae4a9a910e2ccf5661646cf2bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc70ae4a9a910e2ccf5661646cf2bd6">&#9670;&nbsp;</a></span>maximum_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void maximum_flow </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>flow_adjacency_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcula e imprime el flujo máximo en una red de flujo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flow_adjacency_matrix</td><td>Matriz de adyacencia que representa las capacidades de las aristas. </td></tr>
    <tr><td class="paramname">n</td><td>Número de nodos en el grafo. </td></tr>
  </table>
  </dd>
</dl>
<p>Llamamos al algoritmo de Ford-Fulkerson para calcular el flujo máximo</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
